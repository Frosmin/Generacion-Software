[
    {
      "id": 1,
      "title": "¿Qué es la Programación Orientada a Objetos?",
      "paragraph": [
        "La Programación Orientada a Objetos (POO) es un paradigma que organiza el código en 'objetos' que tienen características (atributos) y comportamientos (métodos)."
      ],
      "subcontent": [
        {
          "subtitle": "Conceptos básicos",
          "subparagraph": [
            "Imagina que quieres representar un coche en tu programa. El coche tiene características como color, marca, modelo, y puede realizar acciones como acelerar, frenar, encender."
          ],
          "example": [
            "# Sin POO (usando diccionarios y funciones separadas)\ncoche1 = {\n    'marca': 'Toyota',\n    'modelo': 'Corolla',\n    'color': 'Rojo',\n    'velocidad': 0\n}\n\ndef acelerar_coche(coche, incremento):\n    coche['velocidad'] += incremento\n    print(f'{coche[\"marca\"]} {coche[\"modelo\"]} acelera a {coche[\"velocidad\"]} km/h')\n\n# Con POO (más organizado)\nclass Coche:\n    def __init__(self, marca, modelo, color):\n        self.marca = marca\n        self.modelo = modelo\n        self.color = color\n        self.velocidad = 0\n    \n    def acelerar(self, incremento):\n        self.velocidad += incremento\n        print(f'{self.marca} {self.modelo} acelera a {self.velocidad} km/h')\n\n# Crear y usar objetos\nmi_coche = Coche('Toyota', 'Corolla', 'Rojo')\nmi_coche.acelerar(30)"
          ]
        }
      ],
      "next": "clases_objetos"
    },
    {
      "id": 2,
      "title": "Clases y objetos",
      "paragraph": [
        "Una clase es como un molde o plantilla para crear objetos. Los objetos son instancias específicas de una clase."
      ],
      "subcontent": [
        {
          "subtitle": "Creando tu primera clase",
          "subparagraph": [
            "Una clase define qué atributos y métodos tendrán los objetos creados a partir de ella."
          ],
          "example": [
            "class Persona:\n    # Constructor: se ejecuta al crear un nuevo objeto\n    def __init__(self, nombre, edad, profesion):\n        # Atributos del objeto\n        self.nombre = nombre\n        self.edad = edad\n        self.profesion = profesion\n        self.energia = 100\n    \n    # Métodos: funciones que puede realizar el objeto\n    def presentarse(self):\n        return f'Hola, soy {self.nombre}, tengo {self.edad} años y soy {self.profesion}'\n    \n    def trabajar(self, horas):\n        if self.energia >= horas * 10:\n            self.energia -= horas * 10\n            return f'{self.nombre} trabajó {horas} horas. Energía restante: {self.energia}'\n        else:\n            return f'{self.nombre} está muy cansado para trabajar'\n    \n    def descansar(self, horas):\n        self.energia += horas * 15\n        if self.energia > 100:\n            self.energia = 100\n        return f'{self.nombre} descansó {horas} horas. Energía: {self.energia}'\n\n# Crear objetos (instancias)\npersona1 = Persona('Ana', 28, 'Doctora')\npersona2 = Persona('Carlos', 35, 'Programador')\n\n# Usar los objetos\nprint(persona1.presentarse())\nprint(persona1.trabajar(3))\nprint(persona1.descansar(2))\nprint()\nprint(persona2.presentarse())\nprint(persona2.trabajar(8))"
          ]
        },
        {
          "subtitle": "Atributos de clase vs atributos de instancia",
          "subparagraph": [
            "Los atributos de clase son compartidos por todos los objetos, mientras que los de instancia son únicos para cada objeto."
          ],
          "example": [
            "class Estudiante:\n    # Atributo de clase (compartido por todos los estudiantes)\n    escuela = 'Universidad Python'\n    total_estudiantes = 0\n    \n    def __init__(self, nombre, carrera):\n        # Atributos de instancia (únicos para cada estudiante)\n        self.nombre = nombre\n        self.carrera = carrera\n        self.notas = []\n        \n        # Incrementar contador de clase\n        Estudiante.total_estudiantes += 1\n    \n    def agregar_nota(self, nota):\n        if 0 <= nota <= 100:\n            self.notas.append(nota)\n            return f'Nota {nota} agregada a {self.nombre}'\n        return 'Nota inválida'\n    \n    def promedio(self):\n        if self.notas:\n            return sum(self.notas) / len(self.notas)\n        return 0\n    \n    def info_completa(self):\n        return f'{self.nombre} estudia {self.carrera} en {self.escuela}. Promedio: {self.promedio():.1f}'\n\n# Crear estudiantes\nest1 = Estudiante('María', 'Ingeniería')\nest2 = Estudiante('Pedro', 'Medicina')\n\n# Usar métodos\nprint(est1.agregar_nota(85))\nprint(est1.agregar_nota(92))\nprint(est2.agregar_nota(78))\nprint(est2.agregar_nota(88))\nprint(est2.agregar_nota(95))\n\nprint(est1.info_completa())\nprint(est2.info_completa())\nprint(f'Total de estudiantes: {Estudiante.total_estudiantes}')"
          ]
        }
      ],
      "next": "herencia"
    },
    {
      "id": 3,
      "title": "Herencia",
      "paragraph": [
        "La herencia permite crear nuevas clases basadas en clases existentes, heredando sus atributos y métodos."
      ],
      "subcontent": [
        {
          "subtitle": "Herencia básica",
          "subparagraph": [
            "Una clase hija hereda todo de la clase padre y puede agregar nuevas funcionalidades o modificar las existentes."
          ],
          "example": [
            "# Clase padre (base)\nclass Animal:\n    def __init__(self, nombre, especie):\n        self.nombre = nombre\n        self.especie = especie\n        self.energia = 100\n    \n    def dormir(self):\n        self.energia = 100\n        return f'{self.nombre} durmió y recuperó energía'\n    \n    def comer(self, comida):\n        self.energia += 20\n        return f'{self.nombre} comió {comida}'\n    \n    def info(self):\n        return f'{self.nombre} es un {self.especie} con {self.energia} de energía'\n\n# Clases hijas (derivadas)\nclass Perro(Animal):\n    def __init__(self, nombre, raza):\n        super().__init__(nombre, 'Perro')  # Llamar al constructor del padre\n        self.raza = raza\n        self.lealtad = 100\n    \n    def ladrar(self):\n        self.energia -= 5\n        return f'{self.nombre} ladra: ¡Guau guau!'\n    \n    def jugar(self, actividad):\n        self.energia -= 15\n        self.lealtad += 5\n        return f'{self.nombre} juega {actividad}. Lealtad: {self.lealtad}'\n    \n    def info(self):  # Sobrescribir método del padre\n        return f'{self.nombre} es un {self.raza} con {self.energia} de energía y {self.lealtad} de lealtad'\n\nclass Gato(Animal):\n    def __init__(self, nombre, color):\n        super().__init__(nombre, 'Gato')\n        self.color = color\n        self.independencia = 80\n    \n    def maullar(self):\n        return f'{self.nombre} maúlla: ¡Miau!'\n    \n    def cazar(self, presa):\n        self.energia -= 20\n        self.independencia += 10\n        return f'{self.nombre} cazó un {presa}'\n\n# Crear objetos\nmi_perro = Perro('Rex', 'Golden Retriever')\nmi_gato = Gato('Whiskers', 'Gris')\n\n# Usar métodos heredados y propios\nprint(mi_perro.info())\nprint(mi_perro.ladrar())\nprint(mi_perro.jugar('pelota'))\nprint(mi_perro.comer('croquetas'))\nprint()\nprint(mi_gato.info())\nprint(mi_gato.maullar())\nprint(mi_gato.cazar('ratón'))\nprint(mi_gato.dormir())"
          ]
        },
        {
          "subtitle": "Herencia múltiple",
          "subparagraph": [
            "Python permite que una clase herede de múltiples clases padres."
          ],
          "example": [
            "class Volador:\n    def __init__(self):\n        self.puede_volar = True\n        self.altura_vuelo = 0\n    \n    def volar(self, altura):\n        if self.puede_volar:\n            self.altura_vuelo = altura\n            return f'Volando a {altura} metros de altura'\n        return 'No puede volar'\n    \n    def aterrizar(self):\n        self.altura_vuelo = 0\n        return 'Ha aterizado'\n\nclass Nadador:\n    def __init__(self):\n        self.puede_nadar = True\n        self.profundidad = 0\n    \n    def nadar(self, profundidad):\n        if self.puede_nadar:\n            self.profundidad = profundidad\n            return f'Nadando a {profundidad} metros de profundidad'\n        return 'No puede nadar'\n\n# Herencia múltiple\nclass Pato(Animal, Volador, Nadador):\n    def __init__(self, nombre):\n        Animal.__init__(self, nombre, 'Pato')\n        Volador.__init__(self)\n        Nadador.__init__(self)\n    \n    def graznar(self):\n        return f'{self.nombre} grazna: ¡Cuac cuac!'\n    \n    def actividades_diarias(self):\n        actividades = []\n        actividades.append(self.graznar())\n        actividades.append(self.nadar(2))\n        actividades.append(self.volar(50))\n        actividades.append(self.comer('peces'))\n        actividades.append(self.aterrizar())\n        return actividades\n\n# Crear y usar objeto con herencia múltiple\npato = Pato('Donald')\nprint(pato.info())\nprint('\\nActividades del día:')\nfor actividad in pato.actividades_diarias():\n    print(f'- {actividad}')"
          ]
        }
      ],
      "next": "encapsulamiento"
    },
    {
      "id": 4,
      "title": "Encapsulamiento",
      "paragraph": [
        "El encapsulamiento es el principio de ocultar los detalles internos de una clase y controlar el acceso a sus atributos y métodos."
      ],
      "subcontent": [
        {
          "subtitle": "Atributos privados y protegidos",
          "subparagraph": [
            "En Python usamos convenciones para indicar qué atributos son privados (no se deben usar fuera de la clase)."
          ],
          "example": [
            "class CuentaBancaria:\n    def __init__(self, titular, saldo_inicial=0):\n        self.titular = titular           # Público\n        self._numero_cuenta = self._generar_numero()  # Protegido (convención)\n        self.__saldo = saldo_inicial     # Privado (name mangling)\n        self.__historial = []            # Privado\n    \n    def _generar_numero(self):  # Método protegido\n        import random\n        return f'AC-{random.randint(100000, 999999)}'\n    \n    def depositar(self, cantidad):\n        if cantidad > 0:\n            self.__saldo += cantidad\n            self.__historial.append(f'Depósito: +${cantidad}')\n            return f'Depósito exitoso. Saldo actual: ${self.__saldo}'\n        return 'Cantidad inválida'\n    \n    def retirar(self, cantidad):\n        if cantidad > 0 and cantidad <= self.__saldo:\n            self.__saldo -= cantidad\n            self.__historial.append(f'Retiro: -${cantidad}')\n            return f'Retiro exitoso. Saldo actual: ${self.__saldo}'\n        return 'Fondos insuficientes o cantidad inválida'\n    \n    def consultar_saldo(self):\n        return f'Saldo actual: ${self.__saldo}'\n    \n    def obtener_historial(self):\n        return self.__historial.copy()  # Retorna una copia, no el original\n    \n    def __str__(self):  # Método especial para representación como string\n        return f'Cuenta de {self.titular} ({self._numero_cuenta})'\n\n# Usar la clase\ncuenta = CuentaBancaria('Ana García', 1000)\nprint(cuenta)\nprint(cuenta.consultar_saldo())\nprint(cuenta.depositar(500))\nprint(cuenta.retirar(200))\nprint('Historial:')\nfor transaccion in cuenta.obtener_historial():\n    print(f'  {transaccion}')"
          ]
        },
        {
          "subtitle": "Propiedades (Properties)",
          "subparagraph": [
            "Las propiedades permiten controlar el acceso a los atributos usando métodos que se comportan como atributos."
          ],
          "example": [
            "class Producto:\n    def __init__(self, nombre, precio):\n        self._nombre = nombre\n        self._precio = 0\n        self.precio = precio  # Usar el setter\n        self._descuento = 0\n    \n    @property\n    def nombre(self):\n        return self._nombre\n    \n    @nombre.setter\n    def nombre(self, valor):\n        if isinstance(valor, str) and len(valor) > 0:\n            self._nombre = valor.title()\n        else:\n            raise ValueError('El nombre debe ser una cadena no vacía')\n    \n    @property\n    def precio(self):\n        return self._precio\n    \n    @precio.setter\n    def precio(self, valor):\n        if isinstance(valor, (int, float)) and valor >= 0:\n            self._precio = valor\n        else:\n            raise ValueError('El precio debe ser un número positivo')\n    \n    @property\n    def descuento(self):\n        return self._descuento\n    \n    @descuento.setter\n    def descuento(self, valor):\n        if 0 <= valor <= 100:\n            self._descuento = valor\n        else:\n            raise ValueError('El descuento debe estar entre 0 y 100')\n    \n    @property\n    def precio_final(self):\n        return self._precio * (1 - self._descuento / 100)\n    \n    def __str__(self):\n        if self._descuento > 0:\n            return f'{self._nombre}: ${self._precio} (descuento {self._descuento}%) = ${self.precio_final:.2f}'\n        return f'{self._nombre}: ${self._precio}'\n\n# Usar propiedades\nproducto = Producto('laptop gaming', 1500)\nprint(producto)\n\n# Cambiar valores usando propiedades\nproducto.descuento = 15\nprint(producto)\n\n# Intentar valores inválidos\ntry:\n    producto.precio = -100\nexcept ValueError as e:\n    print(f'Error: {e}')"
          ]
        }
      ],
      "next": "polimorfismo"
    },
    {
      "id": 5,
      "title": "Polimorfismo",
      "paragraph": [
        "El polimorfismo permite que objetos de diferentes clases respondan al mismo método de maneras diferentes."
      ],
      "subcontent": [
        {
          "subtitle": "Polimorfismo básico",
          "subparagraph": [
            "Diferentes clases pueden tener métodos con el mismo nombre pero comportamientos distintos."
          ],
          "example": [
            "class Vehiculo:\n    def __init__(self, marca, modelo):\n        self.marca = marca\n        self.modelo = modelo\n    \n    def acelerar(self):\n        return f'{self.marca} {self.modelo} está acelerando'\n    \n    def frenar(self):\n        return f'{self.marca} {self.modelo} está frenando'\n    \n    def hacer_sonido(self):\n        return 'Sonido de vehículo'\n\nclass Coche(Vehiculo):\n    def hacer_sonido(self):\n        return 'Vroom vroom!'\n    \n    def acelerar(self):\n        return f'{self.marca} {self.modelo} acelera suavemente'\n\nclass Motocicleta(Vehiculo):\n    def hacer_sonido(self):\n        return 'Brum brum!'\n    \n    def acelerar(self):\n        return f'{self.marca} {self.modelo} acelera rápidamente'\n\nclass Camion(Vehiculo):\n    def hacer_sonido(self):\n        return 'Rum rum rum!'\n    \n    def acelerar(self):\n        return f'{self.marca} {self.modelo} acelera pesadamente'\n\n# Polimorfismo en acción\nvehiculos = [\n    Coche('Toyota', 'Corolla'),\n    Motocicleta('Honda', 'CBR'),\n    Camion('Volvo', '700')\n]\n\nprint('Demostrando polimorfismo:')\nfor vehiculo in vehiculos:\n    print(f'- {vehiculo.hacer_sonido()}')\n    print(f'- {vehiculo.acelerar()}')\n    print()"
          ]
        },
        {
          "subtitle": "Métodos abstractos",
          "subparagraph": [
            "Usando ABC (Abstract Base Classes) podemos definir métodos que DEBEN ser implementados por las clases hijas."
          ],
          "example": [
            "from abc import ABC, abstractmethod\n\nclass Figura(ABC):\n    def __init__(self, color):\n        self.color = color\n    \n    @abstractmethod\n    def calcular_area(self):\n        pass\n    \n    @abstractmethod\n    def calcular_perimetro(self):\n        pass\n    \n    def describir(self):\n        return f'Figura de color {self.color}'\n\nclass Rectangulo(Figura):\n    def __init__(self, color, ancho, alto):\n        super().__init__(color)\n        self.ancho = ancho\n        self.alto = alto\n    \n    def calcular_area(self):\n        return self.ancho * self.alto\n    \n    def calcular_perimetro(self):\n        return 2 * (self.ancho + self.alto)\n    \n    def describir(self):\n        return f'Rectángulo {self.color} de {self.ancho}x{self.alto}'\n\nclass Circulo(Figura):\n    def __init__(self, color, radio):\n        super().__init__(color)\n        self.radio = radio\n    \n    def calcular_area(self):\n        import math\n        return math.pi * self.radio ** 2\n    \n    def calcular_perimetro(self):\n        import math\n        return 2 * math.pi * self.radio\n    \n    def describir(self):\n        return f'Círculo {self.color} con radio {self.radio}'\n\n# Usar las figuras\nfiguras = [\n    Rectangulo('azul', 5, 3),\n    Circulo('rojo', 4),\n    Rectangulo('verde', 8, 2)\n]\n\nfor figura in figuras:\n    print(figura.describir())\n    print(f'  Área: {figura.calcular_area():.2f}')\n    print(f'  Perímetro: {figura.calcular_perimetro():.2f}')\n    print()"
          ]
        }
      ],
      "next": "metodos_especiales"
    },
    {
      "id": 6,
      "title": "Métodos especiales (Magic Methods)",
      "paragraph": [
        "Los métodos especiales permiten que nuestras clases se comporten como tipos de datos nativos de Python."
      ],
      "subcontent": [
        {
          "subtitle": "Métodos de representación y comparación",
          "subparagraph": [
            "Estos métodos controlan cómo se muestran y comparan los objetos."
          ],
          "example": [
            "class Libro:\n    def __init__(self, titulo, autor, paginas, precio):\n        self.titulo = titulo\n        self.autor = autor\n        self.paginas = paginas\n        self.precio = precio\n    \n    def __str__(self):\n        # Para print() y str()\n        return f'\"{self.titulo}\" por {self.autor}'\n    \n    def __repr__(self):\n        # Para representación técnica\n        return f'Libro(\"{self.titulo}\", \"{self.autor}\", {self.paginas}, {self.precio})'\n    \n    def __eq__(self, otro):\n        # Para ==\n        if isinstance(otro, Libro):\n            return self.titulo == otro.titulo and self.autor == otro.autor\n        return False\n    \n    def __lt__(self, otro):\n        # Para <\n        if isinstance(otro, Libro):\n            return self.precio < otro.precio\n        return NotImplemented\n    \n    def __len__(self):\n        # Para len()\n        return self.paginas\n\n# Probar métodos especiales\nlibro1 = Libro('1984', 'George Orwell', 328, 15.99)\nlibro2 = Libro('Fahrenheit 451', 'Ray Bradbury', 256, 12.99)\nlibro3 = Libro('1984', 'George Orwell', 328, 15.99)\n\nprint('Representaciones:')\nprint(f'str(): {libro1}')\nprint(f'repr(): {repr(libro1)}')\nprint()\nprint('Comparaciones:')\nprint(f'libro1 == libro3: {libro1 == libro3}')\nprint(f'libro1 == libro2: {libro1 == libro2}')\nprint(f'libro1 < libro2: {libro1 < libro2}')\nprint()\nprint('Longitud:')\nprint(f'len(libro1): {len(libro1)} páginas')"
          ]
        },
        {
          "subtitle": "Métodos aritméticos y de contenedor",
          "subparagraph": [
            "Permiten que nuestros objetos se comporten como números o contenedores."
          ],
          "example": [
            "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __str__(self):\n        return f'Vector({self.x}, {self.y})'\n    \n    def __add__(self, otro):\n        # Para +\n        if isinstance(otro, Vector):\n            return Vector(self.x + otro.x, self.y + otro.y)\n        return NotImplemented\n    \n    def __sub__(self, otro):\n        # Para -\n        if isinstance(otro, Vector):\n            return Vector(self.x - otro.x, self.y - otro.y)\n        return NotImplemented\n    \n    def __mul__(self, escalar):\n        # Para *\n        if isinstance(escalar, (int, float)):\n            return Vector(self.x * escalar, self.y * escalar)\n        return NotImplemented\n    \n    def __abs__(self):\n        # Para abs()\n        import math\n        return math.sqrt(self.x**2 + self.y**2)\n\nclass Inventario:\n    def __init__(self):\n        self.items = {}\n    \n    def __setitem__(self, nombre, cantidad):\n        # Para inventario['item'] = cantidad\n        self.items[nombre] = cantidad\n    \n    def __getitem__(self, nombre):\n        # Para inventario['item']\n        return self.items.get(nombre, 0)\n    \n    def __contains__(self, nombre):\n        # Para 'item' in inventario\n        return nombre in self.items\n    \n    def __len__(self):\n        # Para len(inventario)\n        return len(self.items)\n    \n    def __str__(self):\n        return f'Inventario con {len(self.items)} tipos de items'\n\n# Probar Vector\nv1 = Vector(3, 4)\nv2 = Vector(1, 2)\nprint('Operaciones con vectores:')\nprint(f'v1: {v1}')\nprint(f'v2: {v2}')\nprint(f'v1 + v2: {v1 + v2}')\nprint(f'v1 - v2: {v1 - v2}')\nprint(f'v1 * 2: {v1 * 2}')\nprint(f'abs(v1): {abs(v1):.2f}')\nprint()\n\n# Probar Inventario\ninventario = Inventario()\ninventario['espadas'] = 5\ninventario['pociones'] = 10\ninventario['escudos'] = 3\n\nprint('Inventario:')\nprint(f'Espadas: {inventario[\"espadas\"]}')\nprint(f'¿Hay pociones? {\"pociones\" in inventario}')\nprint(f'¿Hay arcos? {\"arcos\" in inventario}')\nprint(f'Total de tipos: {len(inventario)}')"
          ]
        }
      ],
      "next": null
    }
  ]